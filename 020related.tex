% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\label{sec:relatedworks}

Были рассмотрены и проанализированы существующие в некоторых проектах решения по обеспечению слоя совместимости с программами GNU/Linux.

\subsection{Интерфейс прикладного программирования}
% Абзацы:
%   1. GLIBC POSIX-совместим
%   2. Что в теории дает совместимость на уровне API
%   3. Почему на практике это не работает

Большинство ОС семейства GNU/Linux в той или иной степени совместимы с набором стандартов POSIX, предоставляя один из наиболее популярных интерфейсов прикладного программирования (англ. Application Programming Interface, сокр. API). В частности, библиотека Си проекта GNU (англ. GNU C Library, сокр. GLIBC) является POSIX-совместимой~\cite{glibc-man}.

Теоретически, если в какой-либо ОС стандартная библиотека языка Си предоставляет API стандарта POSIX, то в её окружении возможно запустить приложение, скомпилированное для GNU/Linux:
\begin{enumerate}
    \item приложение успешно совершает вызовы функций, предоставляемых стандартной библиотекой языка Си;
    \item библиотека языка Си обрабатывает эти вызовы (реализует свои функции), используя системные вызовы ядра той ОС, на которой запускается приложение.~\cite[с.~96]{book:linux-kernel-development}
\end{enumerate}

На практике, в большинстве случаев разные ОС поддерживают разные двоичные интерфейсы (англ. Application Binary Interface, сокр. ABI). Например, в одной системе аргументы системных вызовов могут передаваться в регистрах общего назначения, в то время как в другой это происходит посредством стека. Следует вывод, что поддержка общего API в двух разных ОС облегчает процесс переноса приложений между ними, в некоторых (простых) случаях давая возможность без изменений исходного кода программы провести его компиляцию для запуска в иной системе. Для создания полноценного слоя совместимости между двумя ОС необходимо обеспечить совместимость на уровне ABI.

% ----

\subsection{Эмуляция Linux в ОС FreeBSD}
% Абзацы:
%   1. Что и зачем есть в FreeBSD
%   2. Как это работает

ОС FreeBSD подходит для решения различных задач. При этом в ней отсутствует большая часть популярного программного обеспечения, написанного для Linux~\cite{freebsd-docs-chapter11}. В связи с этим разработчиками проекта FreeBSD было принято решение о необходимости внедрения двоичного слоя совместимости с Linux, который был назван <<Эмуляция Linux>>~\cite{freebsd-article-linux-emu}\cite{freebsd-docs-chapter11}. Некоторое программное обеспечение, исполняемые модули которого были предварительно построены для запуска в среде Linux, может быть запущено в FreeBSD благодаря этому слою совместимости.

Слой совместимости устроен следующим образом. API системных вызовов Linux реализован внутри ядра FreeBSD. При запуске исполняемого файла Linux в FreeBSD активируется режим совместимости, который предоставляет процессу этот интерфейс системных вызовов (иными словами~--- таблицу системных вызовов). Исполняемый файл совершает системные вызовы Linux, но их обработкой занимается ядро FreeBSD, которое поддерживает ожидаемую семантику вызовов. Перед обработкой системных вызовов ядром FreeBSD, специальный модуль предварительно готовит окружение. Например, транслирует аргументы функции из регистров (способ передачи аргументов системного вызова в Linux) в стек (способ передачи аргументов системного вызова в FreeBSD). После того, как выполнена вся предварительная подготовка, производится системный вызова FreeBSD, аналогичный совершаемому системному вызову Linux. Перед запуском исполняемого файла Linux требуется настроить изолированное окружение с необходимыми приложению разделяемыми библиотеками и конфигурационными файлами Linux \cite{freebsd-docs-chapter11}.

% ----

\subsection{Слой совместимости на основе виртуализации}
% Абзацы:
%   1. Что это
%   2. Как это работает

На международной конференции <<VEE'20>> была представлена техническая работа <<A Robust and Flexible Operating System Compatibility Architecture>>~\cite{acm-vee-article} (рус. <<Надежная и гибкая архитектура совместимости операционных систем>>). Авторы создали архитектуру слоя двоичной совместимости между двумя системами, показав, что возникновение в ней ошибок не приводит к сбоям системы (<<надёжность>>), а исполняемые файлы Linux могут быть запущены без каких-либо модификаций (<<гибкость>>).

По словам авторов, архитектура основана на идее виртуализации:
\begin{enumerate}
    \item <<гостевой>> процесс (исполняющий <<гостевую>> программу) размещается внутри виртуальной машины без какого-либо ядра ОС;
    \item системные вызовы, инициированные <<гостевым>> процессом, перехватываются обычным процессом текущей ОС;
    \item этот процесс, в свою очередь, эмулирует системные вызовы\\\mbox{<<гостевой>>} системы, используя вызовы текущей системы.~\cite{acm-vee-article}
\end{enumerate}
В качестве примеров, доказывающих работоспособность архитектуры, были представлены небольшие демонстрационные реализации слоя двоичной совместимости с Linux для систем macOS~\cite{noah} и Windows~\cite{noah-windows}.

Такая архитектура представляет собой обобщение рассмотренного выше решения, которое используется в ОС FreeBSD.

% ----

\subsection{Windows Subsystem for Linux}
% Абзацы
%   1. Что и зачем есть в Windows
%   2. Как это работает

В ОС семейства Windows компании Microsoft слой двоичной совместимости с Linux называется <<Windows Subsystem for Linux>> (сокр. WSL). Системы Windows достаточно развиты и не нуждаются в программных решениях GNU/Linux, но компания Microsoft создала для них слой двоичной совместимости. WSL позиционируется в первую очередь как решение для разработчиков, которые работают с открытым исходным кодом, а также для пользователей, предпочитающих пользоваться стандартными программными инструментами GNU/Linux, при этом желающих продолжать пользоваться инструментами повышенной производительности, предоставляемыми Windows~\cite{wsl-faq}.

WSL является первой версией слоя совместимости и представляет собой коллекцию компонентов, позволяющих запускать двоичные исполняемые файлы Linux в среде Windows при помощи специальных драйверов, транслирующих системные вызовы Linux в Windows NT API, эмулируя работу ядра Linux~\cite{wsl-overview}. Такое решение по своей архитектуре близко к подходу, используемому в FreeBSD.

% ----

\subsection{Windows Subsystem for Linux 2}
% Абзацы:
%   1. Зачем была придумана вторая версия WSL
%   2. Как это работает

<<Windows Subsystem for Linux 2>> (сокр. WSL2)~--- новая версия WSL, созданная для решения проблем первой версии. Речь идет, в частности, о поддержке всех системных вызовов Linux, скорости работы с файловыми системами и поддержке слоя совместимости в актуальном состоянии.

Решение основано на новой архитектуре, использующей настоящее ядро Linux, запущенное с использованием технологии виртуализации. Благодаря тому, что в WSL2 роль слоя совместимости выполняет настоящее ядро Linux, стало возможным решить вышеописанные проблемы. Практика показала, что новый слой совместимости работает значительно быстрее прежнего, а последние обновления ядра Linux легко привнести, просто обновив ядро, поставляемое с WSL2~\cite{wsl-2-announce}. Запуск приложений происходит внутри отдельной среды со своей корневой файловой системой, содержащей все необходимые библиотеки и конфигурационные файлы~\cite{wsl-2-linux-files}.

% ----

\subsection{Семейство микроядер L4}
% Абзацы:
%   1. Зачем тут нужен был слой совместимости
%   2. Как это работает

В ОС реального времени Dresden Real-Time Operating System (сокр. DROPS) используется микроядро L4/Fiasco, относящееся к семейству микроядер L4. Для поддержки программ Linux и их запуска в режиме разделяемого времени в среде DROPS был создан проект L\textsuperscript{4}Linux~\cite{l4linux}. В настоящее время этот проект предоставляет многофункциональный инструмент для переноса приложений и разного рода функционала (например, драйверы) в систему L4Re~\cite{l4re}, предназначенную для создания компонентов пространства пользователя~\cite{l4linux}.

L\textsuperscript{4}Linux~--- это ядро Linux, адаптированное для паравиртуализации внутри микроядер семейства L4. Ядро Linux запускается как отдельная, самостоятельная подсистема, обрабатывая поступающие в него запросы.

% ----

\subsection{Библиотека Linux Kernel Library в ОС Embox}
% Абзацы:
%   1. Что это такое и как это работает по задумке авторов
%   2. Как это привнесено и работает в Embox
На девятой международной конференции <<RoEduNet>> была представлена работа <<LKL: The Linux kernel library>>~\cite{lkl-article}, в рамках которой был создан проект Linux Kernel Library~\cite{lkl} (сокр. LKL). Проект позволяет компилировать ядро Linux в одну объектную библиотеку, обеспечивающую простой способ использования кода ядра Linux сторонними приложениями. Библиотека напрямую компонуется с автономным приложением, вызывающим её функции. API, предлагаемый LKL, основан на интерфейсе системных вызовов Linux.

В рамках работы <<Разработка слоя совместимости с Linux приложениями в ОС Embox>>~\cite{lkl-in-embox-slides} в 2019 году автором был подготовлен набор изменений для библиотеки LKL и системы Embox~\cite{lkl-in-embox-patch}, обеспечивающих возможность компоновки этой библиотеки в образ ОС Embox. Благодаря этому стало возможным запускать в среде Embox программы, обращающиеся к библиотеке LKL через её API. Этот результат, однако, не позволяет запускать в среде Embox двоичные файлы GNU/Linux, минуя модификацию исходного кода и компиляцию программ с указанием Embox в качестве целевой ОС.

% ----

\subsection{Проект SGX-LKL}
% Абзацы:
%   1. Что это и как  работает
%   2. Раз так круто, то в чем проблема (сразу подчеркиваем это, еще до "анализа и сравнения")
Применимость проекта LKL оказалась широкой. Работа <<SGX-LKL: Securing the Host OS Interface for Trusted Execution>>~\cite{sgx-lkl} описывает систему <<SGX-LKL>>, созданную для исполнения двоичных файлов Linux в специальной области виртуального адресного пространства, защищенной от чтения и записи извне другими процессами. Такие области памяти (<<анклавы>>) создаются набором инструкций центрального процессора, предоставляемым расширением Intel Software Guard Extensions (сокр. Intel SGX). Библиотека LKL используется в анклаве для обработки системных вызовов Linux.

Стоит отметить, что расширение Intel SGX доступно на ограниченном количестве современных процессоров компании Intel. Также, ввиду особенностей данного расширения, оно не предоставляет механизм для планирования прерываний таймера из анклава, поэтому невозможно реализовать, например, вытесняющую многозадачность, используемую во многих современных ОС. Вместо этого авторы проекта реализовали механизм невытесняющей многозадачности, основывающийся на принципе добровольной передачи управления между процессами~\cite{sgx-threading}. Всё это делает данный проект узкоспециализированным решением, являющимся (как его называют сами авторы) средой исполнения двоичных файлов Linux, но не слоем совместимости, позволяющим запускать двоичные файлы на сторонней ОС.

% ----

\subsection{Анализ и сравнение различных решений}
% Абзацы:
%   1. Вводные слова про актуальность задачи и явное наличие двух подходов к её решению
%   2. Первый тип архитектуры
%   3. Второй тип архитектуры
%   4. Какой тип мы выбираем и почему

Поддержка существующих и создание новых решений говорит о том, что задача обеспечения слоя совместимости с GNU/Linux является актуальной. В решении задачи принимают участие разные группы разработчиков: самостоятельные инженеры, сообщества проектов с открытым исходным кодом, компании-разработчики программного обеспечения. Проблема применимости данных решений в других проектах (и, в частности, в Embox) заключается в сложности адаптации и зависимости от той среды, для которой они разрабатывались изначально. Однако, выделяются две различные архитектурные идеи, лежащие в концепции рассмотренных решений.

Первый архитектурный тип слоя совместимости представляет собой \textit{эмуляцию} работы ядра Linux. Такая архитектура заложена в <<эмуляции Linux>> в ОС FreeBSD, первой версии WSL, а также используется в работе <<A Robust and Flexible Operating System
Compatibility Architecture>>. Идея заключается в предоставлении со стороны ОС некоторого интерфейса, похожего на API системных вызовов Linux, за счет чего обеспечивается слой двоичной совместимости. Такая архитектура доказала свою работоспособность на практике, но она обладает некоторыми недостатками:
\begin{itemize}
    \item сложность реализации и отсутствие изначальной поддержки полного списка системных вызовов Linux (все вызовы добавляются в таком слое совместимости вручную);
    \item поддержка некоторых вызовов может быть реализована некорректно, так как возможности ОС, для которой разрабатывается слой совместимости, могут быть ограничены;
    \item сложность поддержки слоя совместимости в актуальном состоянии относительно последней версии ядра Linux;
    \item отсутствие свойства переносимости~--- реализация эмуляции (подготовка контекста и трансляция системных вызовов Linux) будет значительно отличаться в разных ОС.
\end{itemize}

Второй архитектурный тип слоя совместимости подразумевает запуск адаптированного ядра Linux внутри ОС~--- \textit{паравиртуализацию}. Этот подход используется в проектах L\textsuperscript{4}Linux, WSL2 и SGX-LKL. Такая архитектура лишена недостатков рассмотренной выше эмуляции. Все реализации основываются на разовой подготовке (адаптации) ядра Linux для запуска его внутри системы. Также, такая архитектура оставляет возможность для создания \textit{переносимого} слоя двоичной совместимости, если создать или найти такое паравиртуализируемое ядро Linux, которое будет поддерживаться большим количеством ОС.

Анализ существующих в различных проектах подходов к созданию слоя совместимости с GNU/Linux показал, что разрабатываемая в рамках данной работы архитектура подсистемы слоя совместимости должна основываться на паравиртуализации ядра Linux. Такой подход:
\begin{itemize}
    \item позволит обеспечить высокий уровень совместимости с б\'ольшим количеством приложений;
    \item проще в реализации и поддержке;
    \item оставляет возможность для обеспечения архитектуры слоя двоичной совместимости свойством переносимости.
\end{itemize}
